{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "DashboardServiceMetadataPipeline",
  "type": "object",
  "description": "DashboardService Metadata Pipeline Configuration.",
  "definitions": {
    "dashboardMetadataConfigType": {
      "description": "Dashboard Source Config Metadata Pipeline type",
      "type": "string",
      "enum": [
        "DashboardMetadata"
      ],
      "default": "DashboardMetadata"
    }
  },
  "properties": {
    "type": {
      "description": "Pipeline type",
      "$ref": "#/definitions/dashboardMetadataConfigType",
      "default": "DashboardMetadata"
    },
    "lineageInformation": {
      "description": "Details required to generate Lineage",
      "type": "object",
      "title": "Lineage Information",
      "properties": {
        "dbServicePrefixes": {
          "title": "Database Service Prefixes",
          "description": "List of service path prefixes for lineage matching. Supported formats: DBServiceName, DBServiceName.DatabaseName, DBServiceName.DatabaseName.SchemaName, or DBServiceName.DatabaseName.SchemaName.TableName",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "dashboardFilterPattern": {
      "description": "Regex to exclude or include dashboards that matches the pattern.",
      "$ref": "#/properties/chartFilterPattern",
      "title": "Dashboard Filter Pattern"
    },
    "chartFilterPattern": {
      "description": "Regex exclude or include charts that matches the pattern.",
      "title": "Chart Filter Pattern",
      "type": "object",
      "javaType": "org.openmetadata.schema.metadataIngestion.FilterPattern",
      "properties": {
        "includes": {
          "description": "List of strings/regex patterns to match and include only database entities that match.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "excludes": {
          "description": "List of strings/regex patterns to match and exclude only database entities that match.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "dataModelFilterPattern": {
      "description": "Regex exclude or include data models that matches the pattern.",
      "$ref": "#/properties/chartFilterPattern",
      "title": "Data Model Filter Pattern"
    },
    "projectFilterPattern": {
      "description": "Regex to exclude or include projects that matches the pattern.",
      "$ref": "#/properties/chartFilterPattern",
      "title": "Project Filter Pattern"
    },
    "queryParserConfig": {
      "title": "Query Parser Configuration",
      "description": "Configuration for SQL query parser selection for lineage extraction.",
      "$schema": "http://json-schema.org/draft-07/schema#",
      "type": "object",
      "javaType": "org.openmetadata.schema.metadataIngestion.parserconfig.QueryParserConfig",
      "definitions": {
        "QueryParserType": {
          "description": "Type of SQL query parser to use for lineage and usage extraction. Auto mode is recommended for best results.",
          "type": "string",
          "enum": [
            "Auto",
            "SqlGlot",
            "SqlFluff"
          ],
          "default": "Auto"
        }
      },
      "properties": {
        "type": {
          "title": "Query Parser Type",
          "description": "Choose the SQL parser for lineage extraction:\n• Auto (default): Automatically tries SqlGlot first, falls back to SqlFluff, then SqlParse. Recommended for best results.\n• SqlGlot: High-performance parser with excellent dialect support. Falls back to SqlParse on failure.\n• SqlFluff: Comprehensive parser with strong dialect support. Falls back to SqlParse on failure.",
          "$ref": "#/properties/queryParserConfig/definitions/QueryParserType",
          "default": "Auto"
        }
      },
      "additionalProperties": false
    },
    "includeOwners": {
      "title": "Include Current Owners",
      "description": "Enabling a flag will replace the current owner with a new owner from the source during metadata ingestion, if the current owner is null. It is recommended to keep the flag enabled to obtain the owner information during the first metadata ingestion.",
      "type": "boolean",
      "default": false
    },
    "markDeletedDashboards": {
      "description": "Optional configuration to soft delete dashboards in OpenMetadata if the source dashboards are deleted. Also, if the dashboard is deleted, all the associated entities like lineage, etc., with that dashboard will be deleted",
      "type": "boolean",
      "default": true,
      "title": "Mark Deleted Dashboards"
    },
    "markDeletedDataModels": {
      "description": "Optional configuration to soft delete data models in OpenMetadata if the source data models are deleted. Also, if the data models is deleted, all the associated entities like lineage, etc., with that data models will be deleted",
      "type": "boolean",
      "default": true,
      "title": "Mark Deleted Data Models"
    },
    "includeTags": {
      "description": "Optional configuration to toggle the tags ingestion.",
      "type": "boolean",
      "default": true,
      "title": "Include Tags"
    },
    "includeDataModels": {
      "description": "Optional configuration to toggle the ingestion of data models.",
      "type": "boolean",
      "default": true,
      "title": "Include Data Models"
    },
    "includeDraftDashboard": {
      "title": "Include Draft Dashboards",
      "description": "Optional Configuration to include/exclude draft dashboards. By default it will include draft dashboards",
      "type": "boolean",
      "default": true
    },
    "overrideMetadata": {
      "title": "Override Metadata",
      "description": "Set the 'Override Metadata' toggle to control whether to override the existing metadata in the OpenMetadata server with the metadata fetched from the source. If the toggle is set to true, the metadata fetched from the source will override the existing metadata in the OpenMetadata server. If the toggle is set to false, the metadata fetched from the source will not override the existing metadata in the OpenMetadata server. This is applicable for fields like description, tags, owner and displayName",
      "type": "boolean",
      "default": false
    },
    "overrideLineage": {
      "title": "Override Lineage",
      "description": "Set the 'Override Lineage' toggle to control whether to override the existing lineage.",
      "type": "boolean",
      "default": false
    }
  },
  "additionalProperties": false
}